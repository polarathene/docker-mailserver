(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{104:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return b}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=a.a.createContext({}),l=function(e){var n=a.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=l(e.components);return a.a.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},d=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=l(t),d=r,b=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return t?a.a.createElement(b,i(i({ref:n},p),{},{components:t})):a.a.createElement(b,i({ref:n},p))}));function b(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=t[p];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},96:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return l}));var r=t(3),a=t(7),o=(t(0),t(104)),s={id:"kubernetes",title:"Kubernetes"},i={unversionedId:"kubernetes",id:"kubernetes",isDocsHomePage:!1,title:"Kubernetes",description:"Deployment example",source:"@site/docs/Using-in-Kubernetes.md",slug:"/kubernetes",permalink:"/docker-mailserver/kubernetes",editUrl:"https://github.com/polarathene/docker-mailserver/tree/docs/docusaurus-demo/website/docs/Using-in-Kubernetes.md",version:"current",sidebar:"docs",previous:{title:"Full-text Search",permalink:"/docker-mailserver/fulltext-search"},next:{title:"IPv6",permalink:"/docker-mailserver/ipv6"}},c=[{value:"Deployment example",id:"deployment-example",children:[]},{value:"Exposing to outside world",id:"exposing-to-outside-world",children:[{value:"External IPs Service",id:"external-ips-service",children:[]},{value:"Proxy port to Service",id:"proxy-port-to-service",children:[]},{value:"Bind to concrete Node and use host network",id:"bind-to-concrete-node-and-use-host-network",children:[]},{value:"Proxy port to Service via PROXY protocol",id:"proxy-port-to-service-via-proxy-protocol",children:[]}]},{value:"Let&#39;s Encrypt certificates",id:"lets-encrypt-certificates",children:[]}],p={toc:c};function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"deployment-example"},"Deployment example"),Object(o.b)("p",null,"There is nothing much in deploying mailserver to Kubernetes itself. The things are pretty same as in ",Object(o.b)("a",{parentName:"p",href:"https://github.com/tomav/docker-mailserver/blob/master/docker-compose.yml.dist"},Object(o.b)("inlineCode",{parentName:"a"},"docker-compose.yml")),", but with Kubernetes syntax."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Namespace\nmetadata:\n  name: mailserver\n---  \nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mailserver.env.config\n  namespace: mailserver\n  labels:\n    app: mailserver\ndata:\n  OVERRIDE_HOSTNAME: example.com\n  ENABLE_FETCHMAIL: "0"\n  FETCHMAIL_POLL: "120"\n  ENABLE_SPAMASSASSIN: "0"\n  ENABLE_CLAMAV: "0"\n  ENABLE_FAIL2BAN: "0"\n  ENABLE_POSTGREY: "0"\n  ONE_DIR: "1"\n  DMS_DEBUG: "0"\n\n---\nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mailserver.config\n  namespace: mailserver\n  labels:\n    app: mailserver\ndata:\n  postfix-accounts.cf: |\n    user1@example.com|{SHA512-CRYPT}$6$2YpW1nYtPBs2yLYS$z.5PGH1OEzsHHNhl3gJrc3D.YMZkvKw/vp.r5WIiwya6z7P/CQ9GDEJDr2G2V0cAfjDFeAQPUoopsuWPXLk3u1\n\n  postfix-virtual.cf: |\n    alias1@example.com user1@dexample.com\n\n  #dovecot.cf: |\n  #  service stats {\n  #    unix_listener stats-reader {\n  #      group = docker\n  #      mode = 0666\n  #    }\n  #    unix_listener stats-writer {\n  #      group = docker\n  #      mode = 0666\n  #    }\n  #  }\n\n  SigningTable: |\n    *@example.com mail._domainkey.example.com\n\n  KeyTable: |\n    mail._domainkey.example.com example.com:mail:/etc/opendkim/keys/example.com-mail.key\n\n  TrustedHosts: |\n    127.0.0.1\n    localhost\n \n  #user-patches.sh: |\n  #  #!/bin/bash\n\n  #fetchmail.cf: |\n\n---\nkind: Secret\napiVersion: v1\nmetadata:\n  name: mailserver.opendkim.keys\n  namespace: mailserver\n  labels:\n    app: mailserver\ntype: Opaque\ndata:\n  example.com-mail.key: \'base64-encoded-DKIM-key\'\n\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: mailserver\n  namespace: mailserver\n  labels:\n    app: mailserver\nspec:\n  selector:\n    app: mailserver\n  ports:\n    - name: smtp\n      port: 25\n      targetPort: smtp\n    - name: smtp-secure\n      port: 465\n      targetPort: smtp-secure\n    - name: smtp-auth\n      port: 587\n      targetPort: smtp-auth\n    - name: imap\n      port: 143\n      targetPort: imap\n    - name: imap-secure\n      port: 993\n      targetPort: imap-secure\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mailserver\n  namespace: mailserver\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: mailserver\n  template:\n    metadata:\n      labels:\n        app: mailserver\n        role: mail\n        tier: backend\n    spec:\n      #nodeSelector:\n      #  kubernetes.io/hostname: local.k8s\n      #initContainers:\n      #- name: init-myservice\n      #  image: busybox\n      #  command: ["/bin/sh", "-c", "cp /tmp/user-patches.sh /tmp/files"]\n      #  volumeMounts:\n      #    - name: config\n      #      subPath: user-patches.sh\n      #      mountPath: /tmp/user-patches.sh\n      #      readOnly: true\n      #    - name: tmp-files\n      #      mountPath: /tmp/files\n      containers:\n      - name: docker-mailserver\n        image: tvial/docker-mailserver:latest\n        imagePullPolicy: Always\n        volumeMounts:\n          - name: config\n            subPath: postfix-accounts.cf\n            mountPath: /tmp/docker-mailserver/postfix-accounts.cf\n            readOnly: true\n          #- name: config\n          #  subPath: postfix-main.cf\n          #  mountPath: /tmp/docker-mailserver/postfix-main.cf\n          #  readOnly: true\n          - name: config\n            subPath: postfix-virtual.cf\n            mountPath: /tmp/docker-mailserver/postfix-virtual.cf\n            readOnly: true\n          - name: config\n            subPath: fetchmail.cf\n            mountPath: /tmp/docker-mailserver/fetchmail.cf\n            readOnly: true\n          - name: config\n            subPath: dovecot.cf\n            mountPath: /tmp/docker-mailserver/dovecot.cf\n            readOnly: true\n          #- name: config\n          #  subPath: user1.example.com.dovecot.sieve\n          #  mountPath: /tmp/docker-mailserver/user1@example.com.dovecot.sieve\n          #  readOnly: true\n          #- name: tmp-files\n          #  subPath: user-patches.sh\n          #  mountPath: /tmp/docker-mailserver/user-patches.sh\n          - name: config\n            subPath: SigningTable\n            mountPath: /tmp/docker-mailserver/opendkim/SigningTable\n            readOnly: true\n          - name: config\n            subPath: KeyTable\n            mountPath: /tmp/docker-mailserver/opendkim/KeyTable\n            readOnly: true\n          - name: config\n            subPath: TrustedHosts\n            mountPath: /tmp/docker-mailserver/opendkim/TrustedHosts\n            readOnly: true\n          - name: opendkim-keys\n            mountPath: /tmp/docker-mailserver/opendkim/keys\n            readOnly: true\n          - name: data\n            mountPath: /var/mail\n            subPath: data\n          - name: data\n            mountPath: /var/mail-state\n            subPath: state\n          - name: data\n            mountPath: /var/log/mail\n            subPath: log\n        ports:\n          - name: smtp\n            containerPort: 25\n            protocol: TCP\n          - name: smtp-secure\n            containerPort: 465\n            protocol: TCP\n          - name: smtp-auth\n            containerPort: 587\n          - name: imap\n            containerPort: 143\n            protocol: TCP\n          - name: imap-secure\n            containerPort: 993\n            protocol: TCP\n        envFrom:\n          - configMapRef:\n              name: mailserver.env.config\n      volumes:\n        - name: config\n          configMap:\n            name: mailserver.config\n        - name: opendkim-keys\n          secret:\n            secretName: mailserver.opendkim.keys\n        - name: data\n          persistentVolumeClaim:\n            claimName: mail-storage\n        - name: tmp-files\n          emptyDir: {}\n\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:"),"\nAny sensitive data (keys, etc) should be deployed via ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/secret"},"Secrets"),". Other configuration just fits well into ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/configure-pod-container/configmap"},"ConfigMaps"),"."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:"),"\nMake sure that ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/pod"},"Pod")," is ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/assign-pod-node"},"assigned")," to specific ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/architecture/nodes"},"Node")," in case you're using volume for data directly with ",Object(o.b)("inlineCode",{parentName:"p"},"hostPath"),". Otherwise Pod can be rescheduled on a different Node and previous data won't be found. Except the case when you're using some shared filesystem on your Nodes."),Object(o.b)("h2",{id:"exposing-to-outside-world"},"Exposing to outside world"),Object(o.b)("p",null,"The hard part with Kubernetes is to expose deployed mailserver to outside world. Kubernetes provides multiple ways for doing that. Each has its downsides and complexity."),Object(o.b)("p",null,"The major problem with exposing mailserver to outside world in Kubernetes is to ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/tutorials/services/source-ip"},"preserve real client IP"),". Real client IP is required by mailserver for performing IP-based SPF checks and spam checks."),Object(o.b)("p",null,"Preserving real client IP is relatively ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/tutorials/services/source-ip"},"non-trivial in Kubernetes")," and most exposing ways do not provide it. So, it's up to you to decide which exposing way suits better your needs in a price of complexity."),Object(o.b)("p",null,"If you do not require SPF checks for incoming mails you may disable them in ",Object(o.b)("a",{parentName:"p",href:"https://github.com/tomav/docker-mailserver/wiki/Overwrite-Default-Postfix-Configuration"},"Postfix configuration")," by dropping following line (which removes ",Object(o.b)("inlineCode",{parentName:"p"},"check_policy_service unix:private/policyd-spf")," option):"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mailserver.config\n  labels:\n    app: mailserver\ndata:\n  postfix-main.cf: |\n    smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination, reject_unauth_pipelining, reject_invalid_helo_hostname, reject_non_fqdn_helo_hostname, reject_unknown_recipient_domain, reject_rbl_client zen.spamhaus.org, reject_rbl_client bl.spamcop.net\n# ...\n\n---\n\nkind: Deployment\napiVersion: extensions/v1beta1\nmetadata:\n  name: mailserver\n# ...\n          volumeMounts:\n            - name: config\n              subPath: postfix-main.cf\n              mountPath: /tmp/docker-mailserver/postfix-main.cf\n              readOnly: true\n# ...\n")),Object(o.b)("h3",{id:"external-ips-service"},"External IPs Service"),Object(o.b)("p",null,"The simplest way is to expose mailserver as a ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/service"},"Service")," with ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/service/#external-ips"},"external IPs"),"."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"kind: Service\napiVersion: v1\nmetadata:\n  name: mailserver\n  labels:\n    app: mailserver\nspec:\n  selector:\n    app: mailserver\n  ports:\n    - name: smtp\n      port: 25\n      targetPort: smtp\n# ...\n  externalIPs: \n    - 80.11.12.10  \n")),Object(o.b)("h5",{id:"downsides"},"Downsides"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},"Real client IP is not preserved"),", so SPF check of incoming mail will fail.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Requirement to specify exposed IPs explicitly."))),Object(o.b)("h3",{id:"proxy-port-to-service"},"Proxy port to Service"),Object(o.b)("p",null,"The ",Object(o.b)("a",{parentName:"p",href:"https://github.com/kubernetes/contrib/tree/master/for-demos/proxy-to-service"},"Proxy Pod")," helps to avoid necessity of specifying external IPs explicitly. This comes in price of complexity: you must deploy Proxy Pod on each ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/architecture/nodes"},"Node")," you want to expose mailserver on."),Object(o.b)("h5",{id:"downsides-1"},"Downsides"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Real client IP is not preserved"),", so SPF check of incoming mail will fail.")),Object(o.b)("h3",{id:"bind-to-concrete-node-and-use-host-network"},"Bind to concrete Node and use host network"),Object(o.b)("p",null,"The simplest way to preserve real client IP is to use ",Object(o.b)("inlineCode",{parentName:"p"},"hostPort")," and ",Object(o.b)("inlineCode",{parentName:"p"},"hostNetwork: true")," in the mailserver ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/pod"},"Pod"),". This comes in price of availability: you can talk to mailserver from outside world only via IPs of ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/architecture/nodes"},"Node")," where mailserver is deployed."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"kind: Deployment\napiVersion: extensions/v1beta1\nmetadata:\n  name: mailserver\n# ...\n    spec:\n      hostNetwork: true\n# ...\n      containers:\n# ...      \n          ports:\n            - name: smtp\n              containerPort: 25\n              hostPort: 25\n            - name: smtp-auth\n              containerPort: 587\n              hostPort: 587\n            - name: imap-secure\n              containerPort: 993\n              hostPort: 993\n# ...\n")),Object(o.b)("h5",{id:"downsides-2"},"Downsides"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Not possible to access mailserver via other cluster Nodes, only via the one mailserver deployed at."),Object(o.b)("li",{parentName:"ul"},"Every Port within the Container is exposed on the Host side, regardless of what the ",Object(o.b)("inlineCode",{parentName:"li"},"ports")," section in the Configuration defines. ")),Object(o.b)("h3",{id:"proxy-port-to-service-via-proxy-protocol"},"Proxy port to Service via PROXY protocol"),Object(o.b)("p",null,"This way is ideologically the same as ",Object(o.b)("a",{parentName:"p",href:"#proxy-port-to-service"},"using Proxy Pod"),", but instead of a separate proxy pod, you configure your ingress to proxy TCP traffic to the mailserver pod using the PROXY protocol, which preserves the real client IP."),Object(o.b)("h4",{id:"configure-your-ingress"},"Configure your ingress"),Object(o.b)("p",null,"With an ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.github.io/ingress-nginx/"},"NGINX ingress controller"),", set ",Object(o.b)("inlineCode",{parentName:"p"},"externalTrafficPolicy: Local")," for its service, and add the following to the TCP services config map (as described ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/"},"here"),"):"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},'# ...\n  25:  "mailserver/mailserver:25::PROXY"\n  465: "mailserver/mailserver:465::PROXY"\n  587: "mailserver/mailserver:587::PROXY"\n  993: "mailserver/mailserver:993::PROXY"\n# ...\n')),Object(o.b)("p",null,"With ",Object(o.b)("a",{parentName:"p",href:"https://hub.docker.com/_/haproxy"},"HAProxy"),", the configuration should look similar to the above. If you know what it actually looks like, add an example here. :)"),Object(o.b)("h4",{id:"configure-the-mailserver"},"Configure the mailserver"),Object(o.b)("p",null,"Then, configure both ",Object(o.b)("a",{parentName:"p",href:"https://github.com/tomav/docker-mailserver/wiki/Overwrite-Default-Postfix-Configuration"},"Postfix")," and ",Object(o.b)("a",{parentName:"p",href:"https://github.com/tomav/docker-mailserver/wiki/Override-Default-Dovecot-Configuration"},"Dovecot")," to expect the PROXY protocol:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mailserver.config\n  labels:\n    app: mailserver\ndata:\n  postfix-main.cf: |\n    postscreen_upstream_proxy_protocol = haproxy\n  postfix-master.cf: |\n    submission/inet/smtpd_upstream_proxy_protocol=haproxy\n    smtps/inet/smtpd_upstream_proxy_protocol=haproxy\n  dovecot.cf: |\n    haproxy_trusted_networks = 10.0.0.0/8, 127.0.0.0/8   # Assuming your ingress controller is bound to 10.0.0.0/8\n    service imap-login {\n      inet_listener imaps {\n        haproxy = yes\n      }\n    }\n# ...\n---\n\nkind: Deployment\napiVersion: extensions/v1beta1\nmetadata:\n  name: mailserver\nspec:\n  template:\n    spec:\n      containers:\n        - name: docker-mailserver\n          volumeMounts:\n            - name: config\n              subPath: postfix-main.cf\n              mountPath: /tmp/docker-mailserver/postfix-main.cf\n              readOnly: true\n            - name: config\n              subPath: postfix-master.cf\n              mountPath: /tmp/docker-mailserver/postfix-master.cf\n              readOnly: true\n            - name: config\n              subPath: dovecot.cf\n              mountPath: /tmp/docker-mailserver/dovecot.cf\n              readOnly: true\n# ...\n")),Object(o.b)("h5",{id:"downsides-3"},"Downsides"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Not possible to access mailserver via inner cluster Kubernetes DNS, as PROXY protocol is required for incoming connections.")),Object(o.b)("h2",{id:"lets-encrypt-certificates"},"Let's Encrypt certificates"),Object(o.b)("p",null,Object(o.b)("a",{parentName:"p",href:"https://github.com/jetstack/kube-lego"},"Kube-Lego")," may be used for a role of Let's Encrypt client. It works with Kubernetes ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/ingress"},"Ingress Resources")," and automatically issues/manages certificates/keys for exposed services via Ingresses."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"kind: Ingress\napiVersion: extensions/v1beta1\nmetadata:\n  name: mailserver\n  labels:\n    app: mailserver\n  annotations:\n    kubernetes.io/tls-acme: 'true'\nspec:\n  rules:\n    - host: example.com\n      http:\n        paths:\n          - path: /\n            backend:\n              serviceName: default-backend\n              servicePort: 80\n  tls:\n    - secretName: mailserver.tls\n      hosts:\n        - example.com\n")),Object(o.b)("p",null,"Now, you can use Let's Encrypt cert and key from ",Object(o.b)("inlineCode",{parentName:"p"},"mailserver.tls")," ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/secret"},"Secret"),"\nin your ",Object(o.b)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/pods/pod"},"Pod")," spec."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-yaml"},"# ...\n          env:\n            - name: SSL_TYPE\n              value: 'manual'\n            - name: SSL_CERT_PATH\n              value: '/etc/ssl/mailserver/tls.crt'\n            - name: SSL_KEY_PATH\n              value: '/etc/ssl/mailserver/tls.key'\n# ...\n          volumeMounts:\n            - name: tls\n              mountPath: /etc/ssl/mailserver\n              readOnly: true\n# ...\n      volumes:\n        - name: tls\n          secret:\n            secretName: mailserver.tls\n# ...\n")))}l.isMDXComponent=!0}}]);